<!-- =============================
File: kruskal-prim.html
Project folder: graph
Description: Step-by-step visualizer for Kruskal's and Prim's MST algorithms using Canvas, jQuery, Bootstrap.
Required relative assets:
  ../css/common.css
  ../css/graph/kruskal-prim.css
  ../lib/jquery-3.7.1.min.js
  ../lib/bootstrap-5.3.8-dist/js/bootstrap.min.js
  ../lib/bootstrap-5.3.8-dist/css/bootstrap.min.css
  ../js/graph/kruskal-prim.js
============================= -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Kruskal & Prim — MST Visualizer</title>

  <link rel="stylesheet" href="../lib/bootstrap-5.3.8-dist/css/bootstrap.min.css">
  <link rel="stylesheet" href="../css/common.css">
  <link rel="stylesheet" href="../css/graph/kruskal-prim.css">

  <!-- Basic favicon link -->
  <link rel="icon" href="./../favicon.ico" type="image/x-icon">

</head>
<body>
  <div id="main-content">

    <div class="container py-4">

                <h1 class="analogy-title">Kruskal’s and Prim’s Algorithms: Step-by-Step</h1>

                <p>
                Kruskal’s and Prim’s algorithms are two fundamental methods for finding a 
                <strong>Minimum Spanning Tree (MST)</strong> in a connected, weighted, undirected graph. 
                An MST connects all the vertices together with the smallest possible total edge weight 
                and no cycles.
                </p>

                <hr>

                <h2>How They Work</h2>

                <h3>1. Kruskal’s Algorithm</h3>
                <p>Kruskal’s algorithm builds the MST by sorting and adding edges in order of increasing weight, 
                while ensuring no cycles are formed.</p>

                <ol>
                  <li><strong>Sort Edges:</strong> Begin by sorting all edges in non-decreasing order of their weights.</li>
                  <li><strong>Initialize Sets:</strong> Treat each vertex as its own separate tree (a disjoint set).</li>
                  <li><strong>Pick Edges:</strong> Repeatedly add the smallest-weight edge that connects two different trees (i.e., that does not form a cycle).</li>
                  <li><strong>Union:</strong> Merge (union) the two trees connected by that edge.</li>
                  <li><strong>Stop:</strong> Continue until all vertices are connected (i.e., when there are <code>V – 1</code> edges in the MST).</li>
                </ol>

                <p><strong>Key Idea:</strong> Kruskal’s algorithm grows the MST edge by edge, choosing the next best edge globally.</p>

                <h4>Example (Kruskal’s)</h4>
                <p>Consider a graph with weighted edges:</p>
                <div class="bg-white p-3 rounded border mb-3 font-monospace">
                0–1 (4), 0–2 (3), 1–2 (1), 1–3 (2), 2–3 (4), 3–4 (2)
                </div>

                <ul>
                  <li>Sort edges: (1–2,1), (1–3,2), (3–4,2), (0–2,3), (0–1,4), (2–3,4)</li>
                  <li>Pick (1–2), (1–3), (3–4), (0–2)</li>
                  <li>Stop when 5 vertices are connected. MST edges = {(1–2), (1–3), (3–4), (0–2)}</li>
                  <li><strong>Total weight = 1 + 2 + 2 + 3 = 8</strong></li>
                </ul>

                <hr>

                <h3>2. Prim’s Algorithm</h3>
                <p>
                Prim’s algorithm also finds the MST, but instead of sorting all edges first, it starts from 
                a single vertex and grows the MST one vertex at a time by always choosing the smallest edge 
                that connects a vertex in the tree to one outside.
                </p>

                <ol>
                  <li><strong>Start:</strong> Choose any vertex as the starting point. Mark it as part of the MST.</li>
                  <li><strong>Select Edge:</strong> Among all edges that connect the MST to vertices not yet in the tree, pick the one with the smallest weight.</li>
                  <li><strong>Add Vertex:</strong> Add that edge and the new vertex to the MST.</li>
                  <li><strong>Repeat:</strong> Continue adding the smallest possible edge that connects the MST to a new vertex.</li>
                  <li><strong>End:</strong> When all vertices are included, the MST is complete.</li>
                </ol>

                <p><strong>Key Idea:</strong> Prim’s algorithm grows the MST vertex by vertex from a starting node.</p>

                <h4>Example (Prim’s)</h4>
                <p>Using the same graph as before, starting from vertex 0:</p>
                <ul>
                  <li>Start at 0: edges from 0 → (1,4), (2,3) → choose (0–2).</li>
                  <li>MST = {0–2}. Available edges: (2–1,1), (2–3,4).</li>
                  <li>Pick (2–1,1). MST = {0–2, 2–1}.</li>
                  <li>Next smallest: (1–3,2). MST = {0–2, 2–1, 1–3}.</li>
                  <li>Next: (3–4,2). MST = {0–2, 2–1, 1–3, 3–4}.</li>
                  <li><strong>Total weight = 8</strong> (same as Kruskal’s result).</li>
                </ul>

                <hr>

                <h2>Comparison Between Kruskal’s and Prim’s Algorithms</h2>

                <table class="table table-bordered table-striped">
                  <thead class="table-light">
                    <tr><th>Aspect</th><th>Kruskal’s Algorithm</th><th>Prim’s Algorithm</th></tr>
                  </thead>
                  <tbody>
                    <tr><td>Approach</td><td>Edge-based (global selection)</td><td>Vertex-based (local expansion)</td></tr>
                    <tr><td>Data Structure Used</td><td>Disjoint Set (Union-Find)</td><td>Priority Queue / Min-Heap</td></tr>
                    <tr><td>Graph Type</td><td>Works well on sparse graphs</td><td>Works efficiently on dense graphs</td></tr>
                    <tr><td>Initialization</td><td>Start with all vertices disconnected</td><td>Start from a single source vertex</td></tr>
                    <tr><td>Cycle Detection</td><td>Uses union-find to detect cycles</td><td>No explicit cycle detection needed</td></tr>
                    <tr><td>Time Complexity</td><td>O(E log E)</td><td>O(E log V)</td></tr>
                  </tbody>
                </table>

                <hr>

                <h2>Characteristics</h2>
                <ul>
                  <li><strong>Type:</strong> Both are greedy algorithms that build the MST incrementally.</li>
                  <li><strong>Goal:</strong> Connect all vertices with minimal total weight and no cycles.</li>
                  <li><strong>Applicability:</strong> Used in network design (telecom, roads, power grids, etc.).</li>
                  <li><strong>Output:</strong> A subset of edges forming the MST.</li>
                </ul>

                <hr>

                <h2>Summary</h2>
                <p>
                Kruskal’s and Prim’s algorithms produce the same Minimum Spanning Tree but differ in how they grow it:
                <strong>Kruskal</strong> focuses on choosing the next lightest edge globally, while 
                <strong>Prim</strong> expands from a single node locally.
                Both guarantee the optimal MST for any connected, weighted, undirected graph.
                </p>

                <h2>References</h2>
                <ul>
                    <li><a href="https://www.youtube.com/watch?v=XB4MIexjvY0">3.5 Prims and Kruskals Algorithms - Greedy Method - Abdul Bari - YouTube</a></li>
                </ul>

            </div>



            <div class="container py-4">
              <div class="row g-4">
                <div class="col-12">
                  <h1 class="h3 mb-0">Minimum Spanning Tree — Kruskal & Prim</h1>
                </div>

                <!-- Controls -->
                <div class="col-lg-4">
                  <div class="card shadow-sm">
                    <div class="card-body">
                      <h2 class="h5">Setup</h2>

                      <div class="mb-3">
                        <label class="form-label" for="nodeCount">Number of nodes</label>
                        <input type="number" class="form-control" id="nodeCount" min="2" max="30" value="6" />
                        <div class="form-text">Nodes labeled <code>0..N-1</code>.</div>
                      </div>

                      <div class="row g-2 align-items-end mb-2">
                        <div class="col-4">
                          <label class="form-label" for="edgeU">From</label>
                          <input type="number" class="form-control" id="edgeU" min="0" value="0"/>
                        </div>
                        <div class="col-4">
                          <label class="form-label" for="edgeV">To</label>
                          <input type="number" class="form-control" id="edgeV" min="0" value="1"/>
                        </div>
                        <div class="col-4">
                          <label class="form-label" for="edgeW">Weight</label>
                          <input type="number" class="form-control" id="edgeW" min="1" value="7"/>
                        </div>
                        <div class="col-12 d-flex gap-2">
                          <button class="btn btn-outline-primary btn-sm ms-auto" id="addEdge">Add edge</button>
                          <button class="btn btn-outline-danger btn-sm" id="clearEdges">Clear edges</button>
                        </div>
                      </div>

                      <div class="mb-3">
                        <label class="form-label" for="edgeList">Edge list (one per line: <code>u v w</code>)</label>
                        <textarea class="form-control font-mono" id="edgeList" rows="6">0 1 7
          0 2 9
          0 5 14
          1 2 10
          1 3 15
          2 3 11
          2 5 2
          3 4 6
          4 5 9</textarea>
                      </div>

                      <div class="mb-3">
                        <label class="form-label me-2">Algorithm</label>
                        <div class="btn-group" role="group" aria-label="Algorithm">
                          <input type="radio" class="btn-check" name="algo" id="algoKruskal" autocomplete="off" checked>
                          <label class="btn btn-outline-secondary" for="algoKruskal">Kruskal</label>
                          <input type="radio" class="btn-check" name="algo" id="algoPrim" autocomplete="off">
                          <label class="btn btn-outline-secondary" for="algoPrim">Prim</label>
                        </div>
                      </div>

                      <div class="mb-3" id="primSourceWrap" style="display:none;">
                        <label class="form-label" for="sourceNode">Prim source node</label>
                        <input type="number" class="form-control" id="sourceNode" min="0" value="0"/>
                      </div>

                      <div class="d-flex gap-2">
                        <button class="btn btn-secondary" id="btnSetup">Setup</button>
                        <button class="btn btn-primary" id="btnStep">Step</button>
                        <button class="btn btn-outline-dark" id="btnAuto" title="Run until completion">Auto</button>
                        <button class="btn btn-outline-warning" id="btnReset">Reset</button>
                      </div>

                      <hr/>
                      <h2 class="h6 mb-2">Legend</h2>
                      <ul class="legend list-unstyled small mb-0">
                        <li><span class="legend-swatch mst"></span> In MST</li>
                        <li><span class="legend-swatch consider"></span> Considered edge</li>
                        <li><span class="legend-swatch rejected"></span> Rejected edge</li>
                        <li><span class="legend-swatch frontier"></span> Prim frontier (cut)</li>
                      </ul>
                    </div>
                  </div>
                </div>

                <!-- Canvas + tables -->
                <div class="col-lg-8">
                  <div class="card shadow-sm">
                    <div class="card-body">
                      <div class="d-flex align-items-center justify-content-between mb-2">
                        <h2 class="h5 mb-0">Graph</h2>
                        <div class="small text-muted" id="status">Ready.</div>
                      </div>
                      <canvas id="stage" width="900" height="560" class="w-100 border rounded"></canvas>
                    </div>
                  </div>

                  <div class="row g-3 mt-3">
                    <div class="col-12 col-xl-6">
                      <div class="card shadow-sm h-100">
                        <div class="card-body">
                          <h2 class="h6">Edges (sorted by weight)</h2>
                          <div class="table-responsive">
                            <table class="table table-sm" id="edgeTable">
                              <thead><tr><th>#</th><th>u</th><th>v</th><th>w</th><th>State</th></tr></thead>
                              <tbody></tbody>
                            </table>
                          </div>
                        </div>
                      </div>
                    </div>
                    <div class="col-12 col-xl-6">
                      <div class="card shadow-sm h-100">
                        <div class="card-body">
                          <h2 class="h6">MST Summary</h2>
                          <ul class="mb-2" id="mstList"></ul>
                          <div><strong>Total weight:</strong> <span id="mstWeight">0</span></div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <a class="official-link" href="./../index.html">Data Structures and Algorithms Official Website</a>

             <footer>
              &copy; Progressive Pull. All rights reserved.
            </footer>

  </div>

  <script src="../lib/jquery-3.7.1.min.js"></script>
  <script src="../lib/bootstrap-5.3.8-dist/js/bootstrap.min.js"></script>
  <script src="../js/graph/kruskal-prim.js"></script>
</body>
</html>





