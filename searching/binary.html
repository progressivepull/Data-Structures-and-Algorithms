<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="../css/common.css">
  <title>Binary Search Visual Analogy</title>
  <link rel="stylesheet" href="../css/searching/binary.css">
  <script src="../lib/jquery-3.7.1.min.js"></script>

  <script src="../lib/bootstrap-5.3.8-dist/js/bootstrap.min.js"></script>
  <link rel="stylesheet" href="../lib/bootstrap-5.3.8-dist/css/bootstrap.min.css">


  <!-- Basic favicon link -->
  <link rel="icon" href="./../favicon.ico" type="image/x-icon">
  
</head>
<body>
  <div class="app">
    <header>
      <p><span class="logo"></span> Binary search analogy: books on a shelf</p>
      <div class="controls">
        <label for="target">Target value</label>
        <input id="target" type="number" placeholder="e.g., 42" />
        <label for="n">Boxes</label>
        <input id="n" type="range" min="8" max="36" value="20" />
        <button id="reset" class="secondary">Reset</button>
        <button id="next">Next step</button>
      </div>
    </header>

    <div class="canvas-wrap">
      <canvas id="board" width="1200" height="220" aria-label="Binary search canvas"></canvas>
    </div>

    <div class="legend">
      <div class="chip"><span class="swatch" style="background:#1f2937"></span> In-range boxes</div>
      <div class="chip"><span class="swatch" style="background:#0ea5e9"></span> Midpoint (current guess)</div>
      <div class="chip"><span class="swatch" style="background:#10b981"></span> Found target</div>
      <div class="chip"><span class="swatch" style="background:#ef4444"></span> Out-of-range (eliminated)</div>
    </div>

    <div class="explain" id="explain">
      Enter a target value and click “Next step” to begin. The shelf is sorted left-to-right.
    </div>
  </div>

  <script>
    // ---- Configuration and state ----
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const explain = document.getElementById('explain');
    const targetInput = document.getElementById('target');
    const nRange = document.getElementById('n');
    const nextBtn = document.getElementById('next');
    const resetBtn = document.getElementById('reset');

    let arr = [];
    let lo = 0, hi = 0, mid = 0;
    let target = null;
    let step = 0;
    let foundIndex = -1;
    let started = false;

    // Layout for boxes
    function layoutMetrics(count) {
      const padding = 24;
      const innerW = canvas.width - padding * 2;
      const boxW = Math.max(24, Math.floor(innerW / count) - 6);
      const gap = Math.max(4, Math.floor((innerW - boxW * count) / Math.max(1, count - 1)));
      const y = 70;
      return { padding, boxW, gap, y };
    }

    // Generate a sorted array of distinct values for visualization
    function buildArray(n) {
      const base = 5;
      const step = 4;
      return Array.from({ length: n }, (_, i) => base + i * step);
    }

    // ---- Drawing ----
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Background flourish
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#0b1224');
      grad.addColorStop(1, '#0f172a');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      const n = arr.length;
      const { padding, boxW, gap, y } = layoutMetrics(n);
      const x0 = padding;

      // Range mask (out-of-range becomes dimmed)
      for (let i = 0; i < n; i++) {
        const x = x0 + i * (boxW + gap);
        const inRange = i >= lo && i <= hi;
        const isMid = i === mid;
        const isFound = i === foundIndex;

        // Box
        ctx.fillStyle = inRange ? '#1f2937' : '#1a2234';
        ctx.strokeStyle = inRange ? '#334155' : '#222a3b';
        ctx.lineWidth = 1.5;
        roundRect(ctx, x, y, boxW, 60, 8, true, true);

        // Mid highlight
        if (isMid && started && foundIndex === -1) {
          ctx.save();
          ctx.shadowColor = '#0ea5e9';
          ctx.shadowBlur = 18;
          ctx.strokeStyle = '#0ea5e9';
          ctx.lineWidth = 3;
          roundRect(ctx, x - 2, y - 2, boxW + 4, 64, 10, false, true);
          ctx.restore();
        }

        // Found highlight
        if (isFound) {
          ctx.save();
          ctx.shadowColor = '#10b981';
          ctx.shadowBlur = 20;
          ctx.fillStyle = '#10b981';
          roundRect(ctx, x, y + 62, boxW, 6, 2, true, false);
          ctx.restore();
        }

        // Value text
        ctx.fillStyle = isFound ? '#d1fae5' : inRange ? '#e5e7eb' : '#9ca3af';
        ctx.font = '600 14px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(String(arr[i]), x + boxW / 2, y + 30);
      }

      // Range brackets and labels
      drawRangeBrackets(n, x0, y, boxW, gap);

      // Axis label
      ctx.fillStyle = '#9ca3af';
      ctx.font = '600 12px system-ui';
      ctx.textAlign = 'center';
    }

    function drawRangeBrackets(n, x0, y, boxW, gap) {
      const loX = x0 + lo * (boxW + gap);
      const hiX = x0 + hi * (boxW + gap) + boxW;
      const midX = x0 + mid * (boxW + gap) + boxW / 2;

      // In-range overlay background
      ctx.save();
      ctx.fillStyle = 'rgba(255,255,255,0.04)';
      ctx.fillRect(loX, y - 14, hiX - loX, 14);
      ctx.restore();

      // Brackets
      ctx.strokeStyle = '#93c5fd';
      ctx.lineWidth = 2;
      bracket(ctx, loX, y - 16, false);
      bracket(ctx, hiX, y - 16, true);

      // Mid marker
      ctx.strokeStyle = '#0ea5e9';
      ctx.beginPath();
      ctx.moveTo(midX, y - 22);
      ctx.lineTo(midX, y - 6);
      ctx.stroke();

      // Labels
      ctx.fillStyle = '#93c5fd';
      ctx.font = '600 12px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(`low = ${lo}`, loX + 4, y - 24);
      ctx.textAlign = 'right';
      ctx.fillText(`high = ${hi}`, hiX - 4, y - 52);

      ctx.textAlign = 'center';
      ctx.fillStyle = '#0ea5e9';
      ctx.fillText(`middle = ${mid}`, midX, y - 38);
    }

    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function bracket(ctx, x, y, right = false) {
      ctx.beginPath();
      if (!right) {
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + 10);
        ctx.lineTo(x + 8, y + 10);
      } else {
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + 10);
        ctx.lineTo(x - 8, y + 10);
      }
      ctx.stroke();
    }

    // ---- Explanation text ----
    function setExplain(text, tone = 'neutral') {
      let color = '#dbeafe';
      if (tone === 'ok') color = '#a7f3d0';
      if (tone === 'bad') color = '#fecaca';
      if (tone === 'warn') color = '#fde68a';
      explain.style.color = color;
      explain.innerHTML = text;
    }

    function introText() {
      return `We’re finding a book on a neatly ordered shelf. Each box is a book’s number. 
      Enter a <b>Target value</b>, then click <b>Next step</b>. We’ll only open the middle book each time and narrow the shelf.`;
    }

    function stepText() {
      if (!started) return introText();

      const midVal = arr[mid];
      const loVal = arr[lo], hiVal = arr[hi];

      if (foundIndex !== -1) {
        return `Found it! The middle book is <b>${midVal}</b>, which matches the target <b>${target}</b>. 
        We stop here because opening more books would be unnecessary.`;
      }

      if (lo > hi) {
        return `No match. The search window closed (<b>lo</b> passed <b>hi</b>). 
        That means the target isn’t on this shelf.`;
      }

      if (targetInput.value === '') {
        return `Enter a target value to start. The shelf is sorted, so the middle check tells us which half to ignore.`;
      }

      if (midVal === target) {
        return `Check the middle: book <b>${mid}</b> holds <b>${midVal}</b>. That equals the target <b>${target}</b> — success.`;
      } else if (target < midVal) {
        return `Check the middle: book <b>${mid}</b> holds <b>${midVal}</b>. The target <b>${target}</b> is smaller, 
        so we eliminate the <b>right half</b> and keep the left.`;
      } else {
        return `Check the middle: book <b>${mid}</b> holds <b>${midVal}</b>. The target <b>${target}</b> is larger, 
        so we eliminate the <b>left half</b> and keep the right.`;
      }
    }

    // ---- Binary search stepping ----
    function resetState() {
      const n = parseInt(nRange.value, 10);
      arr = buildArray(n);
      lo = 0;
      hi = n - 1;
      mid = Math.floor((lo + hi) / 2);
      foundIndex = -1;
      step = 0;
      started = false;

      target = parseInt(targetInput.value, 10);
      draw();
      setExplain(introText(), 'neutral');
      nextBtn.disabled = false;
    }

    function nextStep() {
      if (targetInput.value === '') {
        setExplain(`Please enter a target value first.`, 'warn');
        return;
      }

      if (!started) {
        started = true;
        target = parseInt(targetInput.value, 10);
        mid = Math.floor((lo + hi) / 2);
        setExplain(stepText(), 'neutral');
        draw();
        return;
      }

      if (foundIndex !== -1 || lo > hi) {
        nextBtn.disabled = true;
        setExplain(stepText(), foundIndex !== -1 ? 'ok' : 'bad');
        return;
      }

      // Compare at mid
      const midVal = arr[mid];
      if (midVal === target) {
        foundIndex = mid;
        setExplain(stepText(), 'ok');
        draw();
        nextBtn.disabled = true;
        return;
      }

      // Narrow range
      if (target < midVal) {
        hi = mid - 1;
      } else {
        lo = mid + 1;
      }
      mid = Math.floor((lo + hi) / 2);

      // If search closes without finding
      if (lo > hi) {
        setExplain(stepText(), 'bad');
        draw();
        nextBtn.disabled = true;
        return;
      }

      step++;
      setExplain(stepText(), 'neutral');
      draw();
    }

    // ---- Events ----
    resetBtn.addEventListener('click', resetState);
    nextBtn.addEventListener('click', nextStep);
    nRange.addEventListener('input', () => {
      resetState();
    });
    targetInput.addEventListener('change', () => {
      resetState();
    });

    // Initialize
    resetState();

    // ---- Optional: keyboard shortcut ----
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') nextStep();
      if (e.key.toLowerCase() === 'r') resetState();
    });
  </script>
</body>
</html>
